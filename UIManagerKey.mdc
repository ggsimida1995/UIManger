---
description: 
globs: 
alwaysApply: false
---
# UIManager 组件库 - 键盘管理弹窗用法

UIManager提供了多种方式来创建带键盘自适应的弹窗，满足不同的使用场景。本文档重点说明键盘管理弹窗的实现方式及Toast与弹窗的层级关系。

## 键盘管理弹窗的实现方式

UIManager支持四种键盘管理弹窗的实现方式：

1. 内置输入弹窗 API
2. 自定义键盘管理弹窗
3. 多字段表单弹窗
4. 传统扩展方式弹窗

### 1. 内置输入弹窗

最简单的方式，使用内置的`showInputPopup`方法：

```swift
// 内置键盘管理弹窗
func showKeyboardPopup() {
    // 使用内置API创建输入弹窗
    popupManager.showInputPopup(
        title: "内置输入弹窗",
        message: "这是使用内置API的输入弹窗，支持键盘自适应",
        placeholder: "请输入内容...",
        initialText: "",
        keyboardType: .default,
        submitLabel: .done,
        onCancel: {
            toastManager.showToast(message: "取消输入")
        },
        onSubmit: { text in
            if text.isEmpty {
                toastManager.showError(message: "输入内容不能为空")
            } else {
                inputValue = text
                toastManager.showSuccess(message: "输入成功: \(text)")
            }
        }
    )
}
```

### 2. 自定义键盘管理弹窗

当需要更复杂的输入界面时，可以使用`showWithKeyboard`方法：

```swift
// 自定义键盘管理弹窗
func showCustomKeyboardPopup() {
    popupManager.showWithKeyboard { keyboardObserver in
        VStack(spacing: 16) {
            Text("自定义输入弹窗")
                .font(.headline)
                .foregroundColor(themeManager.primaryTextColor)
            
            Text("这是一个带键盘管理的自定义输入弹窗")
                .font(.subheadline)
                .foregroundColor(themeManager.secondaryTextColor)
                .multilineTextAlignment(.center)
            
            TextField("请输入内容...", text: $customInputValue)
                .padding()
                .background(Color(.systemGray6))
                .cornerRadius(8)
                .focused($focusedField, equals: .custom)
            
            // 显示键盘高度
            Text("键盘高度: \(Int(keyboardObserver.keyboardHeight))")
                .font(.caption)
                .foregroundColor(themeManager.secondaryTextColor)
            
            Picker("选择类型", selection: $pickerSelection) {
                Text("选项1").tag(0)
                Text("选项2").tag(1)
                Text("选项3").tag(2)
            }
            .pickerStyle(.segmented)
            .padding(.vertical, 8)
            
            HStack {
                // 按钮...
            }
        }
        .padding()
        .onAppear {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                focusedField = .custom
            }
        }
    }
}
```

### 3. 多字段表单弹窗

处理多个输入字段的表单时使用：

```swift
// 多字段表单弹窗
func showMultiFieldFormPopup() {
    @State var name = ""
    @State var email = ""
    @State var description = ""
    @FocusState var focusedFormField: FormField?
    
    enum FormField {
        case name, email, description
    }
    
    popupManager.showWithKeyboard { keyboardObserver in
        VStack(spacing: 16) {
            Text("多字段表单")
                .font(.headline)
                .foregroundColor(themeManager.primaryTextColor)
            
            ScrollView {
                VStack(spacing: 16) {
                    TextField("姓名", text: $name)
                        // ...设置和样式
                        .focused($focusedFormField, equals: .name)
                        .submitLabel(.next)
                        .onSubmit {
                            focusedFormField = .email
                        }
                    
                    TextField("邮箱", text: $email)
                        // ...设置和样式
                        .focused($focusedFormField, equals: .email)
                        .submitLabel(.next)
                        .onSubmit {
                            focusedFormField = .description
                        }
                    
                    TextEditor(text: $description)
                        // ...设置和样式
                        .focused($focusedFormField, equals: .description)
                }
            }
            
            // 按钮...
        }
        .padding()
        .onAppear {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                focusedFormField = .name
            }
        }
    }
}
```

### 4. 传统扩展方式弹窗

使用View扩展方法创建弹窗：

```swift
// 传统扩展方式弹窗
func showExtensionKeyboardPopup() {
    self.uiPopup {
        VStack(spacing: 16) {
            Text("传统方式弹窗")
                .font(.headline)
                .foregroundColor(themeManager.primaryTextColor)
            
            Text("这个弹窗使用View扩展方法uiPopup实现")
                .font(.subheadline)
                .foregroundColor(themeManager.secondaryTextColor)
                .multilineTextAlignment(.center)
            
            TextField("输入内容", text: $inputValue)
                .padding()
                .background(Color(.systemGray6))
                .cornerRadius(8)
                .focused($focusedField, equals: .standard)
                .onAppear {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        focusedField = .standard
                    }
                }
            
            HStack {
                Button("取消") {
                    // 手动隐藏键盘
                    UIApplication.shared.sendAction(
                        #selector(UIResponder.resignFirstResponder),
                        to: nil, from: nil, for: nil
                    )
                    
                    // 延迟关闭弹窗，让键盘有时间收起
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        self.uiCloseAllPopups()
                        toastManager.showToast(message: "取消传统弹窗")
                    }
                }
                // ...样式
                
                Button("确定") {
                    // 验证和提交逻辑
                }
                // ...样式
            }
        }
        .padding()
    }
}
```

## Toast和弹窗的层级关系

### 确保Toast显示在弹窗上层

为了确保Toast消息始终显示在弹窗之上，UIManager在`withUIComponents()`方法中采用了先应用Popup修饰器，再应用Toast修饰器的顺序：

```swift
// 在UIManager.swift中
public extension View {
    /// 应用所有 UI 组件修饰器
    func withUIComponents() -> some View {
        self.withPopups().withToast()
    }
}
```

这种顺序保证了Toast始终在弹窗上层显示，因此在弹窗中显示验证错误等提示时，不会被弹窗本身遮挡。

### 验证和错误处理最佳实践

当需要在弹窗内验证用户输入并显示错误提示时，推荐使用以下模式：

1. 在提交回调中进行验证
2. 如果验证失败，直接显示Toast错误提示，不关闭弹窗
3. 如果验证成功，关闭弹窗并显示成功提示

```swift
onSubmit: { text in
    if text.isEmpty {
        // 验证失败，显示错误提示，保持弹窗打开
        toastManager.showError(message: "输入内容不能为空")
    } else if isDuplicate(text) {
        // 检查是否重名，显示特定错误
        toastManager.showError(message: "名称已存在，请使用其他名称")
    } else {
        // 验证成功，关闭弹窗并显示成功提示
        popupManager.closeAllPopups()
        inputValue = text
        toastManager.showSuccess(message: "输入成功: \(text)")
    }
}
```

## 注意事项

1. 弹窗关闭后再显示Toast，Toast可能会很快消失，影响用户体验
2. 建议在验证失败时保持弹窗打开，让用户可以直接修改输入
3. 在复杂表单中，可以在表单内部显示错误提示，而不只依赖Toast
4. 在特定场景下，可能需要调整Toast的显示时间(duration)，确保用户有足够时间看到提示